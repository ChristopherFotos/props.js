var props;props=(()=>{"use strict";var t={394:(t,i,s)=>{s.r(i),s.d(i,{Cell:()=>e,Column:()=>n,Grid:()=>o,Prop:()=>u,Scene:()=>p,Vector:()=>h,startScene:()=>g,utils:()=>c});class e{constructor(t,i,s,e){this.x=t,this.y=i,this.size=s,this.scene=e,this.props=[]}addProp(t){this.props.push(t)}removeProp(t){this.props.pop(t)}draw(){this.scene.context.beginPath(),this.scene.context.rect(this.x,this.y,this.size,this.size),this.scene.context.strokeStyle="black",this.scene.context.stroke()}}class n{constructor(t,i,s,e){this.x=t,this.y=i,this.scene=e,this.width=s,this.range=[this.x,this.x+this.width],this.cells=[],this.makeColumn()}addCell(t,i,s,n){this.cells.push(new e(t,i,s,n))}makeColumn(){for(let t=0;t<this.scene.height+(this.width+1);t+=this.width)this.addCell(this.x,t,this.width,this.scene)}}class o{constructor(t,i,s,e){this.scene=t,this.width=i,this.height=s,this.cellSize=e,this.columns=[],this.scene.grid=this,this.createGrid(),this.show=!1}addColumn(t,i,s,e){this.columns.push(new n(t,i,s,e))}createGrid(){for(let t=0;t<this.scene.width+(this.cellSize+1);t+=this.cellSize)this.addColumn(t,0,this.cellSize,this.scene)}findColumns(t){const i=[];return this.columns.forEach((s=>{utils.rangeIntersect(s.x,s.x+s.width,t.position._x,t.position._x+t.width)&&i.push(s)})),i}findCells(t,i){let s=[];return i.cells.forEach((i=>{utils.rangeIntersect(i.y,i.y+i.size,t.position._y,t.position._y+t.height)&&s.push(i)})),s}insertProp(t){t.cells=[],this.findColumns(t).forEach((i=>{let s=this.findCells(t,i);s.forEach((i=>{i.props.push(t),t.cells=t.cells.concat(s)}))}))}insertPropArray(){this.scene.rectProps.forEach((t=>{this.insertProp(t)}))}clearGrid(){this.columns.forEach((t=>{t.cells.forEach((t=>{t.props.length=0}))}))}showGrid(){this.columns.forEach((t=>{t.cells.forEach((t=>{t.draw()}))}))}}window.Grid=o;class h{constructor(t,i){this._x=t,this._y=i}getX(){return this._x}setX(t){this._x=t}getY(){return this._y}setY(t){this._y=t}setAngle(t){var i=this.getLength();this._x=Math.cos(t)*i,this._y=Math.sin(t)*i}getAngle(){return Math.atan2(this._y,this._x)}setLength(t){var i=this.getAngle();this._x=Math.cos(i)*t,this._y=Math.sin(i)*t}getLength(){return Math.sqrt(this._x*this._x+this._y*this._y)}add(t){return vector.create(this._x+t.getX(),this._y+t.getY())}subtract(t){return new h(this._x-t.getX(),this._y-t.getY())}multiply(t){return vector.create(this._x*t,this._y*t)}divide(t){return vector.create(this._x/t,this._y/t)}addTo(t){this._x+=t._x,this._y+=t._y}multiplyBy(t){this._x*=t,this._y*=t}}window.Vector=h;const r={norm:function(t,i,s){return(t-i)/(s-i)},lerp:function(t,i,s){return(s-i)*t+i},map:function(t,i,s,e,n){return r.lerp(r.norm(t,i,s),e,n)},clamp:function(t,i,s){return Math.min(Math.max(t,Math.min(i,s)),Math.max(i,s))},distance:function(t,i){var s=i.x-t.x,e=i.y-t.y;return Math.sqrt(s*s+e*e)},distanceXY:function(t,i,s,e){var n=s-t,o=e-i;return Math.sqrt(n*n+o*o)},circleCollision:function(t,i){return r.distance(t,i)<=t.radius+i.radius},circlePointCollision:function(t,i,s){return r.distanceXY(t,i,s.x,s.y)<s.radius},pointInRect:function(t,i,s){return r.inRange(t,s.x,s.x+s.width)&&r.inRange(i,s.y,s.y+s.height)},inRange:function(t,i,s){return t>=Math.min(i,s)&&t<=Math.max(i,s)},rangeIntersect:function(t,i,s,e){return Math.max(t,i)>=Math.min(s,e)&&Math.min(t,i)<=Math.max(s,e)},rectIntersect:function(t,i){return r.rangeIntersect(t.position._x,t.position._x+t.width,i.position._x,i.position._x+i.width)&&r.rangeIntersect(t.position._y,t.position._y+t.height,i.position._y,i.position._y+i.height)},collisionAxisDetector:function(t,i){},degreesToRads:function(t){return t/180*Math.PI},radsToDegrees:function(t){return 180*t/Math.PI},randomRange:function(t,i){return t+Math.random()*(i-t)},randomInt:function(t,i){return Math.floor(t+Math.random()*(i-t+1))},randomDist:function(t,i,s){for(var e=0,n=0;n<s;n+=1)e+=r.randomRange(t,i);return e/s},compareSigns:function(t,i){return t>0&&i>0||t<0&&i<0},angleTo:function(t,i){Math.atan2(i.y-t.y,i.x-t.x)}},c=r;function l(t,i){let s=t.position._y+t.height,e=i.position._y+i.height,n=t.position._x+t.width,o=i.position._x+i.width,h=e-t.position._y,r=s-i.position._y,c=n-i.position._x,l=o-t.position._x;return r<h&&r<c&&r<l?"top":h<r&&h<c&&h<l?"bottom":c<l&&c<r&&c<h?"left":l<c&&l<r&&l<h?"right":void 0}function a(t,i,s){if("top"===s){let s=t.mass*t.velocity.getLength();i.velocity._y+=s/i.mass*(t.elasticity*i.elasticity)}if("bottom"===s){let s=t.mass*t.velocity.getLength();i.velocity._y-=s/i.mass*(t.elasticity*i.elasticity)}if("left"===s){let s=t.mass*t.velocity.getLength();i.velocity._x+=s/i.mass*(t.elasticity*i.elasticity)}if("right"===s){let s=t.mass*t.velocity.getLength();i.velocity._x-=s/i.mass*(t.elasticity*i.elasticity)}}function d(){this.colliding.coColliders=[],this.colliding.bool=!1;let t=this.collisionCandidates.length;for(let i=0;i<t;i++)c.rectIntersect(this.collisionCandidates[i],this)&&this.collisionCandidates[i]!=this&&(this.colliding.bool=!0,this.colliding.coColliders.push(this.collisionCandidates[i]),this.collisionFunctions&&this.collisionFunctions.forEach((t=>{t.bind(this)(coColliders)})),this.solid&&this.collisionCandidates[i].solid&&(this.customCollisionResponse?this.customCollisionResponse(this,this.collisionCandidates[i],l(this,this.collisionCandidates[i])):a(this,this.collisionCandidates[i],l(this,this.collisionCandidates[i]))))}window.utils=r;class u{constructor(t,{shape:i,radius:s,width:e,stroke:n,fill:o,image:r,strokeColor:c,platform:l=!1,fillColor:a,height:d,x:u,y:p,stackable:g=!0,fixed:y,speed:f,direction:m,mass:x,solid:_,antiTunneling:v,accelMag:w,customProperties:C,customFunctions:M,collisionFunctions:P,friction:S,elasticity:b,minSpeed:A,collision:T,nograv:k,movement:E,movementArray:R,controls:L=[],bitmap:I}={}){this.scene=t,this.shape=i,this.image=r,this.radius=s,this.width=e,this.height=d,this.stroke=n,this.fill=o,this.fillColor=a,this.strokeColor=c,this.collision=T,this.coCollider={},this.platform=l,this.bitmap=I,this.position=new h(u,p),this.direction=m,this.velocity=new h(0,0),this.velocity.setLength(f),this.velocity.setAngle(this.direction),this.stackable=g,this.mass=x,this.solid=_,this.acceleration=new h(0,0),this.acceleration.setLength(w),this.acceleration.setAngle(this.direction),this.movement=E,this.movementArray=R,this.friction=S,this.elasticity=b,this.minSpeed=A,this.controls=L,this.nograv=k,this.fixed=y,this.antiTunneling=v,this.customProperties=C,this.customFunctions=M,this.collisionFunctions=P,this.colliding={},this.collisionCandidates=[],this.checkedCollisionPairs=[],this.cells=[],this.render=!0,this.initToRenderArray(),this.antiTunneling&&setInterval((()=>{this.collide(),this.velocity.getLength()<this.antiTunneling.floor&&this.velocity.setLength(0)}),this.antiTunneling.interval)}initAntiTunneling(){}initToRenderArray(){this.scene.rectProps.unshift(this)}initToCollisionArray(){(this.shape="rectangle")&&this.scene.rectProps.unshift}populateCollisionCandidates(){let t=[];this.cells.forEach((i=>{i.props.forEach((i=>{i==this||t.includes(i)||t.push(i)}))})),this.collisionCandidates=t}accel(){if(this.fixed)this.fixed&&(this.velocity.setLength(1),this.acceleration.setLength(0));else if(this.velocity.addTo(this.acceleration),this.position.addTo(this.velocity),this.velocity.multiplyBy(this.friction),this.acceleration.multiplyBy(this.friction),this.scene.gravity&&!this.nograv&&this.position._y+this.height<this.scene.height-1e-4&&(this.velocity._y+=this.mass),this.movement="default"){let t=this.velocity.getAngle();this.acceleration.setAngle(t)}}edgeBounce(){(this.position._x<0||this.position._x+this.width>this.scene.width)&&(this.acceleration.multiplyBy(-1),this.velocity._x*=this.elasticity),(this.position._y<0||this.position._y+this.height>this.scene.height)&&(this.acceleration.multiplyBy(-1),this.velocity._y*=this.elasticity)}collide(){d.bind(this)()}draw(){(this.shape="rectangle")&&(this.scene.context.beginPath(),this.scene.context.rect(this.position._x,this.position._y,this.width,this.height),this.scene.context.strokeStyle=this.strokeColor,this.scene.context.fillStyle=this.fillColor,this.fill&&this.scene.context.fill(),this.stroke&&this.scene.context.stroke(),this.scene.context.closePath()),this.image&&this.scene.context.drawImage(this.image,this.position._x,this.position._y,this.width,this.height)}update(){this.render?(this.checkedCollisionPairs=[],this.accel(),this.solid&&!this.antiTunneling&&this.collide(),"edgeBounce"===this.collision&&this.edgeBounce(),this.fixedX&&(console.log("fixedX"),this.position._x=this.fixedX),this.fixedY&&(console.log("fixedY"),this.position._y=fixedY),this.customFunctions&&this.customFunctions.forEach((t=>{t.bind(this)()})),this.populateCollisionCandidates(),this.draw()):this.position=new h(void 0,void 0)}}window.Prop=u;class p{constructor(t,i,s,e=!1,n=!0,o=[]){console.log("CLASS CONSTRUCTOR CLASS CONSTRUCTOR"),this.black="blue",this.canvas=document.querySelector(t),this.canvas.width=i,this.canvas.height=s,this.width=this.canvas.width,this.height=this.canvas.height,this.updateArray=o,this.controllers=[],this.gravity=e,this.context=this.canvas.getContext("2d"),this.render=[],this.rectProps=[],this.grid=null}add(t,i){return new u(t,i)}addGrid(t){this.grid=new o(this,this.width,this.height,t)}update(){this.context.clearRect(0,0,this.canvas.width,this.canvas.height),this.updateArray&&this.updateArray.forEach((t=>{t.bind(this)()})),this.controllers.forEach((t=>{t.runController()})),this.grid&&(this.grid.clearGrid(),this.grid.insertPropArray(),this.grid.show&&this.grid.showGrid()),this.rectProps.forEach((t=>{t.update()}))}}function g(t){!function i(){t.update(),requestAnimationFrame(i)}()}window.Scene=p,window.startScene=g,window.Scene=p}},i={};function s(e){if(i[e])return i[e].exports;var n=i[e]={exports:{}};return t[e](n,n.exports,s),n.exports}return s.d=(t,i)=>{for(var e in i)s.o(i,e)&&!s.o(t,e)&&Object.defineProperty(t,e,{enumerable:!0,get:i[e]})},s.o=(t,i)=>Object.prototype.hasOwnProperty.call(t,i),s.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},s(394)})();
//# sourceMappingURL=props.js.map